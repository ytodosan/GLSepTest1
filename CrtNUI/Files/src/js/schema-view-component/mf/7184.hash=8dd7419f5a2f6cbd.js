(self.webpackChunkapp_studio_enterprise_schema_view=self.webpackChunkapp_studio_enterprise_schema_view||[]).push([[7184],{67184:(_,p,f)=>{f.r(p),f.d(p,{HttpClientTestingModule:()=>l,HttpTestingController:()=>d,TestRequest:()=>w,provideHttpClientTesting:()=>h});var s=f(63721),u=f(59131),g=f(62278);/**
 * @license Angular v17.3.12
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */class d{}class w{get cancelled(){return this._cancelled}constructor(e,t){this.request=e,this.observer=t,this._cancelled=!1}flush(e,t={}){if(this.cancelled)throw new Error("Cannot flush a cancelled request.");const n=this.request.urlWithParams,i=t.headers instanceof s.HttpHeaders?t.headers:new s.HttpHeaders(t.headers);e=A(this.request.responseType,e);let a=t.statusText,c=t.status!==void 0?t.status:s.HttpStatusCode.Ok;if(t.status===void 0&&(e===null?(c=s.HttpStatusCode.NoContent,a||="No Content"):a||="OK"),a===void 0)throw new Error("statusText is required when setting a custom status.");c>=200&&c<300?(this.observer.next(new s.HttpResponse({body:e,headers:i,status:c,statusText:a,url:n})),this.observer.complete()):this.observer.error(new s.HttpErrorResponse({error:e,headers:i,status:c,statusText:a,url:n}))}error(e,t={}){if(this.cancelled)throw new Error("Cannot return an error for a cancelled request.");if(t.status&&t.status>=200&&t.status<300)throw new Error("error() called with a successful status.");const n=t.headers instanceof s.HttpHeaders?t.headers:new s.HttpHeaders(t.headers);this.observer.error(new s.HttpErrorResponse({error:e,headers:n,status:t.status||0,statusText:t.statusText||"",url:this.request.urlWithParams}))}event(e){if(this.cancelled)throw new Error("Cannot send events to a cancelled request.");this.observer.next(e)}}function v(r){if(typeof ArrayBuffer>"u")throw new Error("ArrayBuffer responses are not supported on this platform.");if(r instanceof ArrayBuffer)return r;throw new Error("Automatic conversion to ArrayBuffer is not supported for response type.")}function y(r){if(typeof Blob>"u")throw new Error("Blob responses are not supported on this platform.");if(r instanceof Blob)return r;if(ArrayBuffer&&r instanceof ArrayBuffer)return new Blob([r]);throw new Error("Automatic conversion to Blob is not supported for response type.")}function E(r,e="JSON"){if(typeof ArrayBuffer<"u"&&r instanceof ArrayBuffer)throw new Error(`Automatic conversion to ${e} is not supported for ArrayBuffers.`);if(typeof Blob<"u"&&r instanceof Blob)throw new Error(`Automatic conversion to ${e} is not supported for Blobs.`);if(typeof r=="string"||typeof r=="number"||typeof r=="object"||typeof r=="boolean"||Array.isArray(r))return r;throw new Error(`Automatic conversion to ${e} is not supported for response type.`)}function B(r){if(typeof r=="string")return r;if(typeof ArrayBuffer<"u"&&r instanceof ArrayBuffer)throw new Error("Automatic conversion to text is not supported for ArrayBuffers.");if(typeof Blob<"u"&&r instanceof Blob)throw new Error("Automatic conversion to text is not supported for Blobs.");return JSON.stringify(E(r,"text"))}function A(r,e){if(e===null)return null;switch(r){case"arraybuffer":return v(e);case"blob":return y(e);case"json":return E(e);case"text":return B(e);default:throw new Error(`Unsupported responseType: ${r}`)}}class o{constructor(){this.open=[]}handle(e){return new g.Observable(t=>{const n=new w(e,t);return this.open.push(n),t.next({type:s.HttpEventType.Sent}),()=>{n._cancelled=!0}})}_match(e){return typeof e=="string"?this.open.filter(t=>t.request.urlWithParams===e):typeof e=="function"?this.open.filter(t=>e(t.request)):this.open.filter(t=>(!e.method||t.request.method===e.method.toUpperCase())&&(!e.url||t.request.urlWithParams===e.url))}match(e){const t=this._match(e);return t.forEach(n=>{const i=this.open.indexOf(n);i!==-1&&this.open.splice(i,1)}),t}expectOne(e,t){t||=this.descriptionFromMatcher(e);const n=this.match(e);if(n.length>1)throw new Error(`Expected one matching request for criteria "${t}", found ${n.length} requests.`);if(n.length===0){let i=`Expected one matching request for criteria "${t}", found none.`;if(this.open.length>0){const a=this.open.map(m).join(", ");i+=` Requests received are: ${a}.`}throw new Error(i)}return n[0]}expectNone(e,t){t||=this.descriptionFromMatcher(e);const n=this.match(e);if(n.length>0)throw new Error(`Expected zero matching requests for criteria "${t}", found ${n.length}.`)}verify(e={}){let t=this.open;if(e.ignoreCancelled&&(t=t.filter(n=>!n.cancelled)),t.length>0){const n=t.map(m).join(", ");throw new Error(`Expected no open requests, found ${t.length}: ${n}`)}}descriptionFromMatcher(e){if(typeof e=="string")return`Match URL: ${e}`;if(typeof e=="object"){const t=e.method||"(any)",n=e.url||"(any)";return`Match method: ${t}, URL: ${n}`}else return`Match by function: ${e.name}`}static{this.\u0275fac=function(t){return new(t||o)}}static{this.\u0275prov=u.\u0275\u0275defineInjectable({token:o,factory:o.\u0275fac})}}(typeof ngDevMode>"u"||ngDevMode)&&u.\u0275setClassMetadata(o,[{type:u.Injectable}],null,null);function m(r){const e=r.request.urlWithParams;return`${r.request.method} ${e}`}function h(){return[o,{provide:s.HttpBackend,useExisting:o},{provide:d,useExisting:o}]}class l{static{this.\u0275fac=function(t){return new(t||l)}}static{this.\u0275mod=u.\u0275\u0275defineNgModule({type:l})}static{this.\u0275inj=u.\u0275\u0275defineInjector({providers:[h()],imports:[s.HttpClientModule]})}}(typeof ngDevMode>"u"||ngDevMode)&&u.\u0275setClassMetadata(l,[{type:u.NgModule,args:[{imports:[s.HttpClientModule],providers:[h()]}]}],null,null)}}]);
