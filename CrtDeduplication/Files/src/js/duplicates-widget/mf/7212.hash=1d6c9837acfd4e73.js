(self.webpackChunkapp_studio_enterprise_duplicates_widget=self.webpackChunkapp_studio_enterprise_duplicates_widget||[]).push([[7212,4831],{7212:(g,b,u)=>{u.r(b),u.d(b,{outputFromObservable:()=>y,outputToObservable:()=>f,takeUntilDestroyed:()=>l,toObservable:()=>h,toSignal:()=>d});var e=u(59131),a=u(62278),p=u(36486);/**
 * @license Angular v17.3.12
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */function l(r){r||((0,e.assertInInjectionContext)(l),r=(0,e.inject)(e.DestroyRef));const t=new a.Observable(n=>r.onDestroy(n.next.bind(n)));return n=>n.pipe((0,p.takeUntil)(t))}class v{constructor(t){this.source=t,this.destroyed=!1,this.destroyRef=(0,e.inject)(e.DestroyRef),this.destroyRef.onDestroy(()=>{this.destroyed=!0})}subscribe(t){if(this.destroyed)throw new e.\u0275RuntimeError(953,ngDevMode&&"Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");const n=this.source.pipe(l(this.destroyRef)).subscribe({next:s=>t(s)});return{unsubscribe:()=>n.unsubscribe()}}}function y(r,t){return ngDevMode&&(0,e.assertInInjectionContext)(y),new v(r)}function f(r){const t=(0,e.\u0275getOutputDestroyRef)(r);return new a.Observable(n=>{t?.onDestroy(()=>n.complete());const s=r.subscribe(o=>n.next(o));return()=>s.unsubscribe()})}function h(r,t){!t?.injector&&(0,e.assertInInjectionContext)(h);const n=t?.injector??(0,e.inject)(e.Injector),s=new a.ReplaySubject(1),o=(0,e.effect)(()=>{let c;try{c=r()}catch(i){(0,e.untracked)(()=>s.error(i));return}(0,e.untracked)(()=>s.next(c))},{injector:n,manualCleanup:!0});return n.get(e.DestroyRef).onDestroy(()=>{o.destroy(),s.complete()}),s.asObservable()}function d(r,t){ngDevMode&&(0,e.assertNotInReactiveContext)(d,"Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.");const n=!t?.manualCleanup;n&&!t?.injector&&(0,e.assertInInjectionContext)(d);const s=n?t?.injector?.get(e.DestroyRef)??(0,e.inject)(e.DestroyRef):null;let o;t?.requireSync?o=(0,e.signal)({kind:0}):o=(0,e.signal)({kind:1,value:t?.initialValue});const c=r.subscribe({next:i=>o.set({kind:1,value:i}),error:i=>{if(t?.rejectErrors)throw i;o.set({kind:2,error:i})}});if(ngDevMode&&t?.requireSync&&o().kind===0)throw new e.\u0275RuntimeError(601,"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");return s?.onDestroy(c.unsubscribe.bind(c)),(0,e.computed)(()=>{const i=o();switch(i.kind){case 1:return i.value;case 2:throw i.error;case 0:throw new e.\u0275RuntimeError(601,"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.")}})}}}]);
